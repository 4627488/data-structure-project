# 8、B-树应用 （必做） （查找）

## 问题描述

设计并实现B-树的动态查找。

## 基本要求

1. 从文件读取数据
2. 实现B-树的三种基本功能：查找、插入和删除。
3. 以可验证的方式输出结果

## 数据结构

我们使用B-树（B-Tree）来存储和管理数据。B-树是一种自平衡的树数据结构，能够保持数据有序，并允许高效的插入、删除和查找操作。

### B-树节点结构

```cpp
typedef struct BTreeNode {
    int keys[M - 1];
    struct BTreeNode *children[M];
    int numKeys;
    int isLeaf;
} BTreeNode;
```

### B-树结构

```cpp
typedef struct BTree {
    BTreeNode *root;
} BTree;
```

## 算法设计思想

1. **查找**：从根节点开始，逐层向下查找，直到找到目标关键字或到达叶子节点。
2. **插入**：在非满节点中插入关键字，如果节点已满，则需要分裂节点并递归插入。
3. **删除**：从节点中删除关键字，如果节点关键字数不足，则需要合并或借用兄弟节点的关键字。

## 实现的源程序

源程序包括以下文件：

- `prime_gen.c`：生成1到10000的所有质数，并将其写入`primes.txt`文件。
- `main.c`：从文件读取质数，构建B-树，执行查询和删除操作，并将结果写入文件。
- `b_tree.h`：定义B-树的结构和基本操作函数。
- `b_tree.c`：实现B-树的创建、插入、删除、查找和释放内存的功能。
- `Makefile`：编译和链接程序的规则。

## 测试数据和结果

### 生成质数

运行`prime_gen`程序生成`primes.txt`文件，包含1到10000的所有质数。

### 查询和删除操作

1. 查询200-300的每个数是否在B-树中，将结果写入`b-tree1.txt`。
2. 删除500-2000中的每个质数，再查询600-700之间的每个质数是否在，将结果写入`b-tree2.txt`。
3. 插入1-1000的所有偶数，查询100-200的每个偶数是否在B-树中，将结果写入`b-tree3.txt`。

### 结果文件格式

```
XXX no
XXX yes
```

## 算法的时间复杂度

- **查找**：O(log n)
- **插入**：O(log n)
- **删除**：O(log n)

## 改进方法

1. **优化节点分裂和合并**：通过调整节点分裂和合并的策略，可以减少树的高度，提高操作效率。（如：2-3树、2-3-4树）
2. **并行化操作**：在多核处理器上，可以并行化B-树的操作，提高性能。
