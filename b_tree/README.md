# 8、B-树应用 （必做） （查找）

## 问题描述

设计并实现B-树的动态查找。

## 基本要求

1. 从文件读取数据
2. 实现B-树的三种基本功能：查找、插入和删除。
3. 以可验证的方式输出结果

## 文件说明

源程序包括以下文件：

- `prime_gen.c`：生成1到10000的所有质数，并将其写入`primes.txt`文件。
- `main.c`：从文件读取质数，构建B-树，执行查询和删除操作，并将结果写入文件。
- `b_tree.h`：定义B-树的结构和基本操作函数。
- `b_tree.c`：实现B-树的创建、插入、删除、查找和释放内存的功能。
- `Makefile`：编译和链接程序的规则。
- `b-tree1.txt`：查询200-300的每个数是否在B-树中的结果。
- `b-tree2.txt`：删除500-2000中的每个质数，再查询600-700之间的每个质数是否在B-树中的结果。
- `b-tree3.txt`：插入1-1000的所有偶数，查询100-200的每个偶数是否在B-树中的结果。

## 数据结构

使用B-树（B-Tree）来存储和管理数据。B-树是一种自平衡的树数据结构，能够保持数据有序，并允许高效的插入、删除和查找操作。

### B-树节点结构

```cpp
typedef struct BTreeNode {
    int keys[M - 1];
    struct BTreeNode *children[M];
    int numKeys;
    int isLeaf;
} BTreeNode;
```

### B-树结构

```cpp
typedef struct BTree {
    BTreeNode *root;
} BTree;
```

## 算法设计

### 1. B 树

- 阶数 M：节点最多能有 `M-1` 个键和 `M` 个子节点。在这个项目中对应题目要求的 `M=4`。
- 平衡性：B 树始终保持平衡，所有叶子节点在同一深度。
- 关键性质：
  - 每个节点至少包含 ⌈M/2⌉ - 1 个键（根节点除外）。
  - 插入或删除可能导致分裂或合并，以维持平衡性。
  - 所有节点的键按照升序存储，子节点也按区间分布。

### 2. 插入逻辑

#### (1) 插入主函数 `insert`

插入时，首先检查根节点，若根节点为空则创建一个新节点；若根已满，分裂根节点，创建一个新根节点；若根未满，直接调用 `insertNonFull` 递归插入。

```c
if (tree->root == NULL) {
    tree->root = createNode(1);  // 创建根节点
    tree->root->keys[0] = key;
    tree->root->numKeys = 1;
}
```

#### (2) 插入到非满节点 `insertNonFull`

叶子节点：找到合适位置，将键插入。

非叶子节点：查找合适子节点递归插入。如果子节点已满，先分裂该子节点，再插入。

```c
while (i >= 0 && key < node->keys[i]) {
    i--;
}
```

分裂逻辑：调用 `splitChild` 将满的子节点分裂为两个。中间键提升至父节点，并在父节点中增加一个子节点。

```c
splitChild(node, i, node->children[i]);
```

### 3. 删除逻辑

#### (1) 删除主函数 `delete`

递归查找键并删除。删除后，如果根节点变空，减少树的高度。

```c
if (tree->root->numKeys == 0) {
    if (tree->root->isLeaf) {
        tree->root = NULL;
    } else {
        tree->root = tree->root->children[0];
    }
}
```

#### (2) 从节点中删除键 `deleteNode`

若为叶子节点：直接移除键；

若非叶子节点：
  1. 如果子节点包含足够多的键，从中找到前驱或后继替代并删除。
  2. 如果子节点键数不足，则合并相邻子节点，再删除。

```c
if (node->children[idx]->numKeys >= M / 2) {
    removeFromNonLeaf(node, idx);
} else {
    fill(node, idx);
}
```

### 4. 合并和借键逻辑

#### (1) 合并 `merge`

将子节点与其相邻的兄弟节点合并，父节点的一个键也降入合并后的子节点。

合并可能导致父节点键数减少，若父节点键数不足，递归合并父节点。

```c
child->keys[M / 2 - 1] = node->keys[idx];
```

#### (2) 借键 `fill`

若节点键数不足，从兄弟节点借一个键补充。

如果兄弟节点不足，则合并兄弟节点。

```c
if (idx != 0 && node->children[idx - 1]->numKeys >= M / 2) {
    // 从左兄弟借键
} else if (idx != node->numKeys &&
           node->children[idx + 1]->numKeys >= M / 2) {
    // 从右兄弟借键
} else {
    // 合并
}
```
具体实现请参考源代码。

### 5. 查找逻辑

- 递归在节点中查找键，若找到则返回。
- 如果当前节点不包含目标键，则递归到合适的子节点继续查找。

```c
if (i < node->numKeys && key == node->keys[i]) {
    return 1;
}
```

- 若遍历到叶子节点且未找到键，则返回失败。

### 6. 分裂逻辑 `splitChild`

- 当子节点键数达到 `M-1`，将其分裂为两个节点。
- 中间键提升至父节点，分裂过程保证 B 树平衡。

示例：  
假设 `M=4`，节点可以存放 3 个键：  
分裂后：

```
  [10]              [10, 20]
   |         =>       |  |
 [5, 7, 9]         [5, 7] [9]
```

代码中：

- 新节点`newChild`存储右半部分键。
- 原节点`child`保留左半部分键。
- 父节点中插入中间键。

```c
for (int j = 0; j < M / 2 - 1; j++) {
    newChild->keys[j] = child->keys[j + M / 2];
}
```

## 复杂度分析

插入、删除和查找的时间复杂度均为 $O(log N)$
因为树始终保持平衡，节点的高度与键的数量呈对数关系。

## 测试数据和结果

### 生成质数

运行`prime_gen`程序生成`primes.txt`文件，包含1到10000的所有质数。

### 查询和删除操作

1. 查询200-300的每个数是否在B-树中，将结果写入`b-tree1.txt`。
2. 删除500-2000中的每个质数，再查询600-700之间的每个质数是否在，将结果写入`b-tree2.txt`。
3. 插入1-1000的所有偶数，查询100-200的每个偶数是否在B-树中，将结果写入`b-tree3.txt`。

### 结果文件格式

```
XXX no
XXX yes
```

具体请运行后参考`b-tree1.txt`、`b-tree2.txt`和`b-tree3.txt`。

### 插入流程：

```c
insert(tree, 10);
insert(tree, 20);
insert(tree, 5);
insert(tree, 6);
insert(tree, 12);
```

输出结构：

```
     [10]
    /    \
 [5, 6]  [12, 20]
```

### 删除流程：

```c
delete(tree, 6);
```

结构：

```
     [10]
    /    \
  [5]  [12, 20]
```
