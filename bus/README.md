# 7、公交线路提示 (必做) （图）

## 数据结构

1. **Station**: 表示一个公交站点，包含站点名称、站点ID和该站点所属的线路及在线路中的编号。

```c
typedef struct {
    char name[MAX_NAME_LEN];
    int stationId;
    int lines[MAX_LINE][2]; // <lineId, InlineId>
    int lineCount;
} Station;
```

2. **Line**: 表示一条公交线路，包含线路名称、线路ID和该线路经过的站点ID。

```c
typedef struct {
    char name[MAX_NAME_LEN];
    int lineId;
    int stationIds[MAX_STATION];
    int stationCount;
} Line;
```

3. **PrevNode**: 表示路径中的前一个节点，包含站点ID和线路ID。

```c
typedef struct {
    int stationId;
    int lineId;
} PrevNode;
```

## 算法设计思想

1. **读取CSV文件**: 读取CSV文件并解析每一行数据，构建站点和线路的映射关系。

```c
void readCSV(const char *filename);
```

2. **最少转车次数的乘车路线**: 使用Dijkstra算法，计算从起始站点到终点站点的最少转车次数的路线。

```c
void findTransferLeastPath(int start, int end);
```

3. **经过站点数量最少的乘车路线**: 使用Dijkstra算法，计算从起始站点到终点站点的经过站点数量最少的路线。

```c
void findLeastStationPath(int start, int end);
```

## 测试数据和结果

### 测试数据

CSV文件内容如下：

```
线路名,站点,公交线路ID,线内ID,站点ID
1路(建康路·夫子庙--南堡公园),建康路·夫子庙,0,0,1942
1路(建康路·夫子庙--南堡公园),长白街,0,1,6196
1路(建康路·夫子庙--南堡公园),太平巷,0,2,4319
...
```

完整的CSV文件见 `nanjing.csv`。

### 测试结果

输入起始站点和终点站点，程序输出最少转车次数和经过站点数量最少的乘车路线。

```
请输入起始站点: 南航北门
请输入终点站点: 理工大
---------------------------------
最少转车次数: 1
路线:
南航北门
  |
  | 乘坐 719路(武夷绿洲--南京南站)
  |
茶花路
  |
  | 乘坐 84路(南京南站--理工大)
  |
理工大
---------------------------------
经过站点数量最少: 8
路线:
南航北门
  |
  | 乘坐 719路(武夷绿洲--南京南站)
  |
翠屏山
  |
  | 乘坐 711路(综保区场站--安德门)
  |
托乐嘉
  |
  | 乘坐 711路(综保区场站--安德门)
  |
麻田路
  |
  | 乘坐 768路(宁杭高铁江宁站--安德门)
  |
景明佳园
  |
  | 乘坐 61路(景明佳园--江东中路·江东门北街)
  |
应天大街
  |
  | 乘坐 306路(楠溪江东街--银城东苑)
  |
莫愁湖公园南门
  |
  | 乘坐 306路(楠溪江东街--银城东苑)
  |
瑞金路
  |
  | 乘坐 Y14路夜间(中花岗总站--公交四公司)
  |
孝陵卫
  |
  | 乘坐 5路(南湾营--长江路·估衣廊)
  |
理工大
```

## 数据结构

- **`Station`**: 存储地铁站的信息，包括站点名称、站点ID、每条线路在此站点的编号（`lines`数组）以及该站点的线路数量。
- **`Line`**: 存储地铁线路的信息，包括线路名称、线路ID、每条线路上所有站点的ID（`stationIds`数组）以及该线路的站点数量。
- **`MinHeap`**: 一个小根堆数据结构，用于Dijkstra算法中的优先队列实现。
- **`HeapNode`**: 小根堆中的元素，存储站点的ID和当前的最短距离。
- **`PrevNode`**: 用于记录从起点到当前站点的前驱站点以及所使用的线路ID，帮助追踪路径。

## 算法分析

### 1. **最少转车次数的路径计算** (`findTransferLeastPath`)
此算法的目标是找到从起始站到终点站的最少转车次数路径。算法步骤如下：

- 初始化每个站点的最短转车次数为 `INT_MAX`，起始站点的转车次数为 0。
- 使用小根堆（`MinHeap`）实现 Dijkstra 算法。每次弹出堆顶元素，查看当前站点可以到达的所有其他站点，并更新其最短转车次数。
- 在更新站点的转车次数时，如果当前站点与相邻站点属于同一条线路，则不需要转车；否则，转车次数加1。
- 使用 `PrevNode` 数组记录路径，从终点通过前驱站点回溯，输出最少转车路径。

### 复杂度分析（`findTransferLeastPath`）

- 每个站点的邻接关系通过线路表示。假设每条线路有 `L` 个站点，且有 `M` 条线路，站点的总数为 `S`，则每个站点的邻接关系最多为 `L`（每条线路的站点数量）。
- Dijkstra 算法的时间复杂度为 $O((S + L) * log(S))$，其中 `S` 为站点数，`L` 为线路上的站点数。由于每条线路都有很多相邻站点，更新的复杂度较高。

### 2. **经过站点数量最少的路径计算** (`findLeastStationPath`)
此算法的目标是找到从起始站到终点站的最短路径，最短路径是指经过站点的数量最少，而不是最少的转车次数。算法的基本思路类似于 Dijkstra 算法，但它考虑的是路径中站点数量而非转车次数。

- 和最少转车次数路径的计算类似，初始化每个站点的距离为 `INT_MAX`，起始站点的距离为 0。
- 使用小根堆（`MinHeap`）实现 Dijkstra 算法，更新邻接站点的站点数量最小路径。
- 每次访问相邻站点时，检查当前站点是否属于同一线路，并更新路径。
- 路径回溯时也使用 `PrevNode` 数组来追踪每个站点的前驱站点和使用的线路。

### 复杂度分析（`findLeastStationPath`）

- 和最少转车次数路径计算类似，复杂度为 $O((S + L) * log(S))$，其中 `S` 是站点数，`L` 是线路上的站点数。

### 总体复杂度

由于程序实现中，最主要的计算是 Dijkstra 算法。假设站点数量为 $S$，线路数量为 $L$，则每次更新的时间复杂度为 $O(log S)$，整体的复杂度是：

- **空间复杂度**：$O(S + L)$，用于存储站点信息、线路信息以及小根堆。
- **时间复杂度**：$O((S + L) * log(S))$，其中 $S$ 是站点数，$L$ 是线路数。