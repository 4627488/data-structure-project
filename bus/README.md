# 7、公交线路提示 (必做) （图）

## 数据结构

1. **Station**: 表示一个公交站点，包含站点名称、站点ID和该站点所属的线路及在线路中的编号。

```c
typedef struct {
    char name[MAX_NAME_LEN];
    int stationId;
    int lines[MAX_LINE][2]; // <lineId, InlineId>
    int lineCount;
} Station;
```

2. **Line**: 表示一条公交线路，包含线路名称、线路ID和该线路经过的站点ID。

```c
typedef struct {
    char name[MAX_NAME_LEN];
    int lineId;
    int stationIds[MAX_STATION];
    int stationCount;
} Line;
```

3. **PrevNode**: 表示路径中的前一个节点，包含站点ID和线路ID。

```c
typedef struct {
    int stationId;
    int lineId;
} PrevNode;
```

## 算法设计思想

1. **读取CSV文件**: 读取CSV文件并解析每一行数据，构建站点和线路的映射关系。

```c
void readCSV(const char *filename);
```

2. **最少转车次数的乘车路线**: 使用Dijkstra算法，计算从起始站点到终点站点的最少转车次数的路线。

```c
void findTransferLeastPath(int start, int end);
```

3. **经过站点数量最少的乘车路线**: 使用Dijkstra算法，计算从起始站点到终点站点的经过站点数量最少的路线。

```c
void findLeastStationPath(int start, int end);
```

## 测试数据和结果

### 测试数据

CSV文件内容如下：

```
线路名,站点,公交线路ID,线内ID,站点ID
1路(建康路·夫子庙--南堡公园),建康路·夫子庙,0,0,1942
1路(建康路·夫子庙--南堡公园),长白街,0,1,6196
1路(建康路·夫子庙--南堡公园),太平巷,0,2,4319
...
```

完整的CSV文件见 `nanjing.csv`。

### 测试结果

输入起始站点和终点站点，程序输出最少转车次数和经过站点数量最少的乘车路线。

```
请输入起始站点: 南航北门
请输入终点站点: 理工大
---------------------------------
最少转车次数: 1
路线:
南航北门
  |
  | 乘坐 719路(武夷绿洲--南京南站)
  |
茶花路
  |
  | 乘坐 84路(南京南站--理工大)
  |
理工大
---------------------------------
经过站点数量最少: 8
路线:
南航北门
  |
  | 乘坐 719路(武夷绿洲--南京南站)
  |
翠屏山
  |
  | 乘坐 711路(综保区场站--安德门)
  |
托乐嘉
  |
  | 乘坐 711路(综保区场站--安德门)
  |
麻田路
  |
  | 乘坐 768路(宁杭高铁江宁站--安德门)
  |
景明佳园
  |
  | 乘坐 61路(景明佳园--江东中路·江东门北街)
  |
应天大街
  |
  | 乘坐 306路(楠溪江东街--银城东苑)
  |
莫愁湖公园南门
  |
  | 乘坐 306路(楠溪江东街--银城东苑)
  |
瑞金路
  |
  | 乘坐 Y14路夜间(中花岗总站--公交四公司)
  |
孝陵卫
  |
  | 乘坐 5路(南湾营--长江路·估衣廊)
  |
理工大
```

## 算法的时间复杂度

1. **最少转车次数的乘车路线**: 使用Dijkstra算法，时间复杂度为 $O(E + V \log V)$，其中 $E$ 是边的数量，$V$ 是顶点的数量。具体来说：

   - 初始化距离数组和优先队列的时间复杂度为 $O(V)$。
   - 每个顶点最多会被加入优先队列一次，加入和取出优先队列的时间复杂度为 $O(\log V)$，因此总的时间复杂度为 $O(V \log V)$。
   - 每条边最多会被处理一次，处理每条边的时间复杂度为 $O(1)$，因此总的时间复杂度为 $O(E)$。
   - 综合起来，Dijkstra算法的时间复杂度为 $O(E + V \log V)$。

2. **经过站点数量最少的乘车路线**: 使用Dijkstra算法，时间复杂度为 $O(E + V \log V)$，其中 $E$ 是边的数量，$V$ 是顶点的数量。具体来说：
   - 初始化距离数组和优先队列的时间复杂度为 $O(V)$。
   - 每个顶点最多会被加入优先队列一次，加入和取出优先队列的时间复杂度为 $O(\log V)$，因此总的时间复杂度为 $O(V \log V)$。
   - 每条边最多会被处理一次，处理每条边的时间复杂度为 $O(1)$，因此总的时间复杂度为 $O(E)$。
   - 综合起来，Dijkstra算法的时间复杂度为 $O(E + V \log V)$。

