# 1、系统进程统计（必做）（链表）

## 简介

本程序读取系统进程信息，统计进程的内存使用情况，以及进程的运行时间。程序使用链表数据结构来存储和管理进程信息。本题目代码共 {{ procs_lines }} 行。

## 环境要求

- 本程序支持在 Linux、Windows 和 macOS 环境下运行。
- 在 `6.12.4-arch1-1 ArchLinux x86_64`、`Windows 11 24H2` 和 `macOS Sequoia 15.0` 系统上测试通过。

## 数据结构

- **活动进程链表**（`Process`）：
  存储当前正在运行的进程，按内存使用量排序。每个节点包括：进程名称、内存使用量、启动时间、未更新标记（标识进程是否已结束）。

- **已结束进程链表**（`EndedProcess`）：
  存储已结束的进程，按持续时间排序。每个节点包括：进程名称、持续时间、结束时间。

## 算法主要思想

该程序的目的是监控当前活动的进程以及已结束的进程，并输出这些进程的相关信息。算法基于链表数据结构来管理进程信息，同时按进程的内存使用量或持续时间排序。

### 主要步骤：

1. **活动进程和已结束进程的储存**：

   - 使用链表 `active_head` 存储当前活动的进程。每个活动进程包括进程名称、内存使用、启动时间以及更新标记。
   - 使用双向链表 `ended_head` 存储已结束的进程。活动进程按内存使用量降序序排列。每个已结束进程包含进程名称、持续时间、结束时间等信息。

2. **更新数据**：

   - 在 Linux 系统中，每个进程都有一个对应的目录 `/proc/PID`，其中包含了进程的相关信息。程序会定期读取 `/proc` 目录下的进程信息，更新活动进程链表和已结束进程链表。
   - 在 Windows 系统中，程序使用 Windows API 获取进程信息。
   - 在 macOS 系统中，程序使用 `sysctl` 和 `libproc` 获取进程信息。

1. 每次循环开始时，程序会将所有活动进程标记为未更新。
2. 然后遍历系统中的进程，检查每个进程的状态。若某个进程不在活动进程链表中，则将其添加到活动进程链表中；否则更新该进程的内存使用量和运行时间，并将其标记为已更新。
3. 最后，检查活动进程链表中的进程，将有未更新标记的进程移动到已结束进程链表中的适当位置（按持续时间升序排列）。

1. **打印数据**：
   - 程序会定期输出当前活动进程及已结束进程的信息。活动进程的输出包含进程名称、运行时长、内存使用量。已结束进程的输出包括进程名称、持续时间及结束时间。

### 执行流程

1. **初始化链表**：

   - `active_head` 和 `ended_head` 分别初始化为空链表，用来存储活动进程和已结束进程。

2. **更新进程状态**：

   - 调用 `update_active_processes()` 更新活动进程，获取系统中的进程信息，添加新的进程或更新已存在进程。
   - 调用 `update_ended_processes()` 更新已结束进程，检查没有更新的活动进程并将其移动到已结束列表。

3. **输出当前状态**：

   - `print_active_processes()` 打印当前活动进程的信息。
   - `print_ended_processes()` 打印已结束进程的信息。

4. **重复2、3步骤**：
   - 程序会定期更新（1秒）进程状态和输出当前状态，直到程序被终止。

## 算法的时间复杂度

在最坏情况下，时间复杂度是 $O(NM + MK)$。其中 `N` 是系统中的进程数量，`M` 是活动进程链表的长度，`K` 是已结束进程链表的长度。

下面分别分析每个函数的时间复杂度：

- **`update_active_processes()`**：每次循环需要遍历系统中的所有进程，时间复杂度为 $O(N)$，其中 `N` 是系统中进程的数量。对于每个进程，可能需要遍历活动进程链表进行插入操作，最坏情况下为 $O(M)$，其中 `M` 是活动进程链表的长度。因此，该函数的总时间复杂度是 $O(N * M)$。

- **`update_ended_processes()`**：遍历活动进程链表检查未更新的进程，并将其移动到已结束进程链表中。最坏情况下，删除操作和插入操作分别需要 $O(1)$ 和 $O(K)$ 时间，其中 `K` 是已结束进程链表的长度。因此，该函数的时间复杂度是 $O(M * K)$。

- **`print_active_processes()` 和 `print_ended_processes()`**：分别遍历活动进程链表和已结束进程链表，时间复杂度分别为 $O(M)$ 和 $O(K)$
