# 9、排序算法比较 （必做）（排序）

## 问题描述

利用随机函数产生10个样本，每个样本有100000个随机整数（并使第一个样本是正序，第二个样本是逆序），利用直接插入排序、希尔排序，冒泡排序、快速排序、选择排序、堆排序，归并排序、基数排序8种排序方法进行排序（结果为由小到大的顺序），并统计每一种排序算法对不同样本所耗费的时间。

## 要求

1. 原始数据存在文件中，用相同样本对不同算法进行测试；
2. 屏幕显示每种排序算法对不同样本所花的时间；
3. 任意选择1个样本完成数字排序，即统计出每个整数出现的次数，按出现次数从多到少的顺序输出（输出的信息包含数字和出现的频率）。提示：可用一个数组，以下标作为数，数组内容存储该数出现次数来实现（这就相当于直接映射，是机试题目里面常用的一种解题法，很多看似非线性的题型最后其实都可以采取哈希或者映射的方法来巧解，体会哈希思想在机试题目中的巧用）。

## 数据结构

使用 `std::vector<int>` 来存储样本数据。

## 算法设计思想

1. 生成10个样本，每个样本包含100000个随机整数，并将它们存储在文件中。
2. 实现8种排序算法：直接插入排序、希尔排序、冒泡排序、快速排序、选择排序、堆排序、归并排序、基数排序。
3. 对每个样本使用不同的排序算法进行排序，并统计每种算法的耗时。
4. 显示每种排序算法对不同样本所花的时间。
5. 对任意选择的一个样本进行数字排序，并统计每个整数出现的次数，按出现次数从多到少的顺序输出。

## 测试数据和结果

程序生成10个样本数据文件，每个文件包含100000个随机整数。对每个样本使用8种排序算法进行排序，并统计每种算法的耗时。以下是部分测试结果示例：

```
====样本1======
直接插入排序排序耗时: 0.00053369秒
希尔排序排序耗时: 0.00685221秒
冒泡排序排序耗时: 17.5284秒
快速排序排序耗时: 37.1794秒
选择排序排序耗时: 17.3865秒
堆排序排序耗时: 0.0254844秒
归并排序排序耗时: 0.0227283秒
基数排序排序耗时: 0.0163487秒
====样本2======
直接插入排序排序耗时: 17.9416秒
希尔排序排序耗时: 0.00990094秒
冒泡排序排序耗时: 44.5773秒
快速排序排序耗时: 21.6641秒
选择排序排序耗时: 16.859秒
堆排序排序耗时: 0.0239351秒
归并排序排序耗时: 0.0226194秒
基数排序排序耗时: 0.0159799秒
====样本3======
直接插入排序排序耗时: 8.96412秒
希尔排序排序耗时: 0.0278527秒
冒泡排序排序耗时: 36.0912秒
快速排序排序耗时: 0.016276秒
选择排序排序耗时: 17.4401秒
堆排序排序耗时: 0.029981秒
归并排序排序耗时: 0.0316348秒
基数排序排序耗时: 0.0162168秒
====样本4======
直接插入排序排序耗时: 9.04911秒
希尔排序排序耗时: 0.0281864秒
冒泡排序排序耗时: 36.6653秒
快速排序排序耗时: 0.0152831秒
选择排序排序耗时: 17.5027秒
堆排序排序耗时: 0.0301401秒
归并排序排序耗时: 0.0317878秒
基数排序排序耗时: 0.0166479秒
```

## 算法的时间复杂度

- 直接插入排序: O(n^2)
- 希尔排序: O(n log n) ~ O(n^2)
- 冒泡排序: O(n^2)
- 快速排序: O(n log n) 最坏情况 O(n^2)
- 选择排序: O(n^2)
- 堆排序: O(n log n)
- 归并排序: O(n log n)
- 基数排序: O(nk)

## 改进方法

对于快速排序，可以使用三向切分快速排序来优化处理重复元素较多的情况。对于基数排序，可以使用更高效的计数排序来进一步优化。
