# 6、地铁修建 (必做) （图）

## 编译运行

```bash
make test
```

这会自动测试样例。

## 数据结构

本项目采用了以下数据结构：

**边结构体（Edge）**：用于存储每条隧道的信息，包括其连接交通枢纽和所需的施工时间。在图中，每条边可以看作是一段隧道，权重表示修建时间。`Edge`数组存储了所有候选隧道的信息。

```c
typedef struct {
    int u, v, w; // 边的两个顶点和权重
} Edge;
```

**并查集（DSU）**：并查集是一种动态维护连通分量的数据结构，支持路径压缩和按秩合并，优化查找和合并效率。在本题中用于快速判断加入某条边后是1号枢纽和n号枢纽是否连通。

```c
int *fa = (int *)malloc((n + 1) * sizeof(int));
int *rank = (int *)calloc(n + 1, sizeof(int));
```

- **`fa[]`**：表示并查集中每个节点的父节点，初始时，每个节点的父节点是自己。
- **`rank[]`**：记录每个节点的秩（树的高度），用于按秩合并，防止树过深。

## 算法设计思想

#### 1. **Kruskal算法**（最小生成树）

- **核心思想**：Kruskal算法通过贪心思想，逐步选择权重最小的边，构建最小生成树。
- **算法步骤**：

  1. 将所有边按权重升序排序。
  2. 依次遍历排序后的边，若该边连接的两个节点属于不同的连通分量，则加入该边。
  3. 重复上述过程，直到形成连通路径或生成树。

- **复杂度**：
  - **排序阶段**：$O(m \log m)$，$m$ 为边的数量。
  - **并查集操作**：$O(m*\alpha(n))$，其中 $\alpha$ 是反 $Ackermann$ 函数，近似常数级别。

#### 2. **并查集（Union-Find）**

```c
int find(int fa[], int u) {
    if (fa[u] != u) {
        fa[u] = find(fa, fa[u]); // 路径压缩
    }
    return fa[u];
}
```

**查找操作（`find`）**：

- 采用路径压缩，使查找复杂度接近 `O(1)`。

**合并操作（`unite`）**：

- 使用按秩合并，使树的高度尽可能保持较小。

#### 3. **最小瓶颈路（Max-Min Path）算法**

在生成树中找到从1号节点到n号节点的最小瓶颈路径，即使路径中最大的边权尽可能小。在加入边的过程中记录最大边权重，当1号节点和n号节点连通时，即可得到路径上的最大边权。

## 测试数据和结果

### 测试数据

```
6 6
1 2 4
2 3 4
3 6 7
1 4 2
4 5 5
5 6 6
```

### 测试结果

```
6
```

## 算法的时间复杂度

Kruskal 算法的时间复杂度主要由排序和并查集操作决定：

- 排序的时间复杂度为$O(m\log m)$，其中m是边的数量。
- 并查集操作的时间复杂度接近于$O(1)$，因此整体时间复杂度为$O(m\log m)$。
